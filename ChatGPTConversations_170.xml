<application>
  <component name="ee.carlrobert.codegpt.state.conversations.ConversationsState">
    <option name="conversationsContainer" value="{&quot;conversationsMapping&quot;:{&quot;codegpt.chat.completion&quot;:[{&quot;id&quot;:&quot;eda112f2-0535-4909-9dcb-13b97b41f175&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;как добавить отключение экрана через 10 минут?&quot;,&quot;id&quot;:&quot;fe0ab114-4fc8-4774-81c2-5439eea7c8d5&quot;,&quot;response&quot;:&quot;## Plan\n\n1. Implement a screen timeout feature that turns off the screen after 10 minutes of inactivity\n2. Use a combination of WindowManager flags and a timer mechanism\n3. Add necessary methods to handle screen timeout functionality\n4. Integrate with existing activity lifecycle\n\n## Implementation\n\n```kotlin\n// Add these imports at the top\nimport android.os.Handler\nimport android.os.Looper\nimport android.view.WindowManager\n\n// Add these properties to the Reader2Activity class\nprivate val screenTimeoutHandler = Handler(Looper.getMainLooper())\nprivate val screenTimeoutRunnable = Runnable {\n    window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n}\nprivate val SCREEN_TIMEOUT_DELAY = 10 * 60 * 1000L // 10 minutes in milliseconds\n\n// Add these methods to the Reader2Activity class\nprivate fun startScreenTimeoutTimer() {\n    // First ensure screen stays on\n    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n    // Schedule timeout\n    screenTimeoutHandler.removeCallbacks(screenTimeoutRunnable)\n    screenTimeoutHandler.postDelayed(screenTimeoutRunnable, SCREEN_TIMEOUT_DELAY)\n}\n\nprivate fun resetScreenTimeoutTimer() {\n    startScreenTimeoutTimer()\n}\n\nprivate fun stopScreenTimeoutTimer() {\n    screenTimeoutHandler.removeCallbacks(screenTimeoutRunnable)\n    window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n}\n\n// Modify onCreate to start the timer\noverride fun onCreate(savedInstanceState: Bundle?) {\n    // Existing code...\n    \n    startScreenTimeoutTimer()\n    \n    // Add touch listener to reset timer on user interaction\n    findViewById&lt;android.view.View&gt;(android.R.id.content).setOnTouchListener { _, _ -&gt;\n        resetScreenTimeoutTimer()\n        false // Don't consume the event\n    }\n}\n\n// Modify onStop to clean up\noverride fun onStop() {\n    stopScreenTimeoutTimer()\n    viewModel.onActivityStop()\n    super.onStop()\n}\n```\n\nThis implementation will keep the screen on initially, then allow it to turn off after 10 minutes of inactivity. The timer resets whenever the user touches the screen.&quot;,&quot;referencedFilePaths&quot;:[&quot;/Users/pavelperc/arcadia/bookmate/android/feature/reader2/src/main/java/com/bookmate/feature/reader2/ui2/Reader2Activity.kt&quot;],&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null},{&quot;prompt&quot;:&quot;Your task is to provide a clear, concise explanation of what this code does. Focus on the main functionality and purpose of the code, avoiding unnecessary details. Explain any complex logic or algorithms if present.\n\nProvide your explanation in a few sentences, using simple language that a junior programmer could understand. If there are any notable best practices or potential improvements, briefly mention them at the end.\n\nHere's the code to analyze:\n\n```kt\n  override fun onCreate(savedInstanceState: Bundle?) {\n        val style = SystemBarStyle.dark(Color.TRANSPARENT)\n        enableEdgeToEdge(style, style)\n        super.onCreate(savedInstanceState)\n        setContent {\n            ReaderTheme {\n                Reader2Screen(viewModel)\n            }\n        }\n\n```&quot;,&quot;id&quot;:&quot;b117f698-3e37-47bb-a0b0-9133afea07f4&quot;,&quot;response&quot;:&quot;This code initializes the Reader2Activity when it's created. It sets up a dark transparent style for the system bars (status bar and navigation bar) and enables edge-to-edge display, which allows content to flow under the system bars. Then it calls the parent class's onCreate method and sets the content of the activity using Jetpack Compose. The content consists of a Reader2Screen component wrapped in a ReaderTheme, with the viewModel passed as a parameter to provide data and handle user interactions.\n\nThe main purpose is to set up the UI for an e-book reader with a modern edge-to-edge design. A potential improvement would be to extract the UI styling logic into a separate method to make the onCreate method more concise and focused on initialization.&quot;,&quot;referencedFilePaths&quot;:null,&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;codegpt.chat.completion&quot;,&quot;model&quot;:&quot;gpt-4o-mini&quot;,&quot;createdOn&quot;:[2025,3,24,13,10,27,115326000],&quot;updatedOn&quot;:[2025,3,24,13,19,3,904322000],&quot;discardTokenLimit&quot;:false}],&quot;anthropic.chat.completion&quot;:[{&quot;id&quot;:&quot;528b39ad-5f4a-4ddc-98eb-532538979511&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;Your task is to create concise, effective tests for the given code.\n\nGenerate unit tests for the provided code. Focus on:\n1. Testing main functionalities\n2. Edge cases\n3. Input validation\n\nProvide your test code in the same language as the original code. Use common testing frameworks and assertions appropriate for the language.\n\nHere's the code to write tests for:\n\n```kt\n    fun &lt;T&gt; observePref(prop: KProperty0&lt;T&gt;): Flow&lt;T&gt; = flow {\n        emit(prop.get())\n        emitAll(prefUpdateFlow.filter { it.name == prop.name }.map { prop.get() })\n    }\n```&quot;,&quot;id&quot;:&quot;2d557090-672f-43ec-abec-a8b95491431f&quot;,&quot;response&quot;:&quot;## Test Plan\n\n1. Test that `observePref` emits the current value immediately\n2. Test that `observePref` emits new values when the property changes\n3. Test that `observePref` only emits for the specific property being observed\n4. Test with different property types (String, Int, Boolean, custom object)\n5. Test edge case: rapid property changes\n\n```kotlin\npackage com.bookmate.common.android.preferences\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.test.core.app.ApplicationProvider\nimport app.cash.turbine.test\nimport io.mockk.every\nimport io.mockk.mockk\nimport io.mockk.verify\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.test.runTest\nimport org.junit.Assert.assertEquals\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.reflect.KProperty0\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalCoroutinesApi\nclass AbstractPreferencesTest {\n\n    private lateinit var testPreferences: TestPreferences\n    private lateinit var mockContext: Context\n    private lateinit var mockSharedPreferences: SharedPreferences\n    private lateinit var mockEditor: SharedPreferences.Editor\n\n    @Before\n    fun setup() {\n        mockContext = mockk(relaxed = true)\n        mockSharedPreferences = mockk(relaxed = true)\n        mockEditor = mockk(relaxed = true)\n        \n        every { mockContext.getSharedPreferences(any(), any()) } returns mockSharedPreferences\n        every { mockSharedPreferences.edit() } returns mockEditor\n        every { mockEditor.putString(any(), any()) } returns mockEditor\n        every { mockEditor.apply() } returns Unit\n        \n        testPreferences = TestPreferences()\n        testPreferences.init(mockContext)\n    }\n\n    @Test\n    fun `observePref emits current value immediately`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When\n        val flow = testPreferences.observePref(testPreferences::stringPref)\n        \n        // Then\n        val value = flow.first()\n        assertEquals(\&quot;initial\&quot;, value)\n    }\n\n    @Test\n    fun `observePref emits new values when property changes`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;initial\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;final\&quot;\n            assertEquals(\&quot;final\&quot;, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref only emits for specific property`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;string\&quot;\n        testPreferences.intPref = 42\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;string\&quot;, awaitItem())\n            \n            // Change different property\n            testPreferences.intPref = 100\n            \n            // Change observed property\n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            expectNoEvents()\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref works with different property types`() = runTest {\n        // Given\n        testPreferences.intPref = 42\n        testPreferences.boolPref = true\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test {\n            assertEquals(42, awaitItem())\n            testPreferences.intPref = 100\n            assertEquals(100, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n        \n        testPreferences.observePref(testPreferences::boolPref).test {\n            assertEquals(true, awaitItem())\n            testPreferences.boolPref = false\n            assertEquals(false, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref handles rapid property changes`() = runTest {\n        // Given\n        testPreferences.intPref = 0\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test(timeout = 5.seconds) {\n            assertEquals(0, awaitItem())\n            \n            // Rapidly change property multiple times\n            for (i in 1..100) {\n                testPreferences.intPref = i\n            }\n            \n            // Should eventually receive the final value\n            assertEquals(100, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    private class TestPreferences : AbstractPreferences(\&quot;test_prefs\&quot;) {\n        var stringPref by SharedPreferenceDelegate.create&lt;String&gt;()\n        var intPref by SharedPreferenceDelegate.create&lt;Int&gt;()\n        var boolPref by SharedPreferenceDelegate.create&lt;Boolean&gt;()\n    }\n}\n```&quot;,&quot;referencedFilePaths&quot;:null,&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,24,13,21,55,136260000],&quot;updatedOn&quot;:[2025,3,24,13,26,42,431793000],&quot;discardTokenLimit&quot;:false}]}}" />
    <option name="currentConversation" value="{&quot;id&quot;:&quot;528b39ad-5f4a-4ddc-98eb-532538979511&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;Your task is to create concise, effective tests for the given code.\n\nGenerate unit tests for the provided code. Focus on:\n1. Testing main functionalities\n2. Edge cases\n3. Input validation\n\nProvide your test code in the same language as the original code. Use common testing frameworks and assertions appropriate for the language.\n\nHere's the code to write tests for:\n\n```kt\n    fun &lt;T&gt; observePref(prop: KProperty0&lt;T&gt;): Flow&lt;T&gt; = flow {\n        emit(prop.get())\n        emitAll(prefUpdateFlow.filter { it.name == prop.name }.map { prop.get() })\n    }\n```&quot;,&quot;id&quot;:&quot;2d557090-672f-43ec-abec-a8b95491431f&quot;,&quot;response&quot;:&quot;## Test Plan\n\n1. Test that `observePref` emits the current value immediately\n2. Test that `observePref` emits new values when the property changes\n3. Test that `observePref` only emits for the specific property being observed\n4. Test with different property types (String, Int, Boolean, custom object)\n5. Test edge case: rapid property changes\n\n```kotlin\npackage com.bookmate.common.android.preferences\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.test.core.app.ApplicationProvider\nimport app.cash.turbine.test\nimport io.mockk.every\nimport io.mockk.mockk\nimport io.mockk.verify\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.test.runTest\nimport org.junit.Assert.assertEquals\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.reflect.KProperty0\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalCoroutinesApi\nclass AbstractPreferencesTest {\n\n    private lateinit var testPreferences: TestPreferences\n    private lateinit var mockContext: Context\n    private lateinit var mockSharedPreferences: SharedPreferences\n    private lateinit var mockEditor: SharedPreferences.Editor\n\n    @Before\n    fun setup() {\n        mockContext = mockk(relaxed = true)\n        mockSharedPreferences = mockk(relaxed = true)\n        mockEditor = mockk(relaxed = true)\n        \n        every { mockContext.getSharedPreferences(any(), any()) } returns mockSharedPreferences\n        every { mockSharedPreferences.edit() } returns mockEditor\n        every { mockEditor.putString(any(), any()) } returns mockEditor\n        every { mockEditor.apply() } returns Unit\n        \n        testPreferences = TestPreferences()\n        testPreferences.init(mockContext)\n    }\n\n    @Test\n    fun `observePref emits current value immediately`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When\n        val flow = testPreferences.observePref(testPreferences::stringPref)\n        \n        // Then\n        val value = flow.first()\n        assertEquals(\&quot;initial\&quot;, value)\n    }\n\n    @Test\n    fun `observePref emits new values when property changes`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;initial\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;final\&quot;\n            assertEquals(\&quot;final\&quot;, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref only emits for specific property`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;string\&quot;\n        testPreferences.intPref = 42\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;string\&quot;, awaitItem())\n            \n            // Change different property\n            testPreferences.intPref = 100\n            \n            // Change observed property\n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            expectNoEvents()\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref works with different property types`() = runTest {\n        // Given\n        testPreferences.intPref = 42\n        testPreferences.boolPref = true\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test {\n            assertEquals(42, awaitItem())\n            testPreferences.intPref = 100\n            assertEquals(100, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n        \n        testPreferences.observePref(testPreferences::boolPref).test {\n            assertEquals(true, awaitItem())\n            testPreferences.boolPref = false\n            assertEquals(false, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref handles rapid property changes`() = runTest {\n        // Given\n        testPreferences.intPref = 0\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test(timeout = 5.seconds) {\n            assertEquals(0, awaitItem())\n            \n            // Rapidly change property multiple times\n            for (i in 1..100) {\n                testPreferences.intPref = i\n            }\n            \n            // Should eventually receive the final value\n            assertEquals(100, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    private class TestPreferences : AbstractPreferences(\&quot;test_prefs\&quot;) {\n        var stringPref by SharedPreferenceDelegate.create&lt;String&gt;()\n        var intPref by SharedPreferenceDelegate.create&lt;Int&gt;()\n        var boolPref by SharedPreferenceDelegate.create&lt;Boolean&gt;()\n    }\n}\n```&quot;,&quot;referencedFilePaths&quot;:null,&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,24,13,21,55,136260000],&quot;updatedOn&quot;:[2025,3,24,13,26,42,431793000],&quot;discardTokenLimit&quot;:false}" />
  </component>
</application>