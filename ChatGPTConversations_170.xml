<application>
  <component name="ee.carlrobert.codegpt.state.conversations.ConversationsState">
    <option name="conversationsContainer" value="{&quot;conversationsMapping&quot;:{&quot;codegpt.chat.completion&quot;:[{&quot;id&quot;:&quot;eda112f2-0535-4909-9dcb-13b97b41f175&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;как добавить отключение экрана через 10 минут?&quot;,&quot;id&quot;:&quot;fe0ab114-4fc8-4774-81c2-5439eea7c8d5&quot;,&quot;response&quot;:&quot;## Plan\n\n1. Implement a screen timeout feature that turns off the screen after 10 minutes of inactivity\n2. Use a combination of WindowManager flags and a timer mechanism\n3. Add necessary methods to handle screen timeout functionality\n4. Integrate with existing activity lifecycle\n\n## Implementation\n\n```kotlin\n// Add these imports at the top\nimport android.os.Handler\nimport android.os.Looper\nimport android.view.WindowManager\n\n// Add these properties to the Reader2Activity class\nprivate val screenTimeoutHandler = Handler(Looper.getMainLooper())\nprivate val screenTimeoutRunnable = Runnable {\n    window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n}\nprivate val SCREEN_TIMEOUT_DELAY = 10 * 60 * 1000L // 10 minutes in milliseconds\n\n// Add these methods to the Reader2Activity class\nprivate fun startScreenTimeoutTimer() {\n    // First ensure screen stays on\n    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n    // Schedule timeout\n    screenTimeoutHandler.removeCallbacks(screenTimeoutRunnable)\n    screenTimeoutHandler.postDelayed(screenTimeoutRunnable, SCREEN_TIMEOUT_DELAY)\n}\n\nprivate fun resetScreenTimeoutTimer() {\n    startScreenTimeoutTimer()\n}\n\nprivate fun stopScreenTimeoutTimer() {\n    screenTimeoutHandler.removeCallbacks(screenTimeoutRunnable)\n    window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n}\n\n// Modify onCreate to start the timer\noverride fun onCreate(savedInstanceState: Bundle?) {\n    // Existing code...\n    \n    startScreenTimeoutTimer()\n    \n    // Add touch listener to reset timer on user interaction\n    findViewById&lt;android.view.View&gt;(android.R.id.content).setOnTouchListener { _, _ -&gt;\n        resetScreenTimeoutTimer()\n        false // Don't consume the event\n    }\n}\n\n// Modify onStop to clean up\noverride fun onStop() {\n    stopScreenTimeoutTimer()\n    viewModel.onActivityStop()\n    super.onStop()\n}\n```\n\nThis implementation will keep the screen on initially, then allow it to turn off after 10 minutes of inactivity. The timer resets whenever the user touches the screen.&quot;,&quot;referencedFilePaths&quot;:[&quot;/Users/pavelperc/arcadia/bookmate/android/feature/reader2/src/main/java/com/bookmate/feature/reader2/ui2/Reader2Activity.kt&quot;],&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null},{&quot;prompt&quot;:&quot;Your task is to provide a clear, concise explanation of what this code does. Focus on the main functionality and purpose of the code, avoiding unnecessary details. Explain any complex logic or algorithms if present.\n\nProvide your explanation in a few sentences, using simple language that a junior programmer could understand. If there are any notable best practices or potential improvements, briefly mention them at the end.\n\nHere's the code to analyze:\n\n```kt\n  override fun onCreate(savedInstanceState: Bundle?) {\n        val style = SystemBarStyle.dark(Color.TRANSPARENT)\n        enableEdgeToEdge(style, style)\n        super.onCreate(savedInstanceState)\n        setContent {\n            ReaderTheme {\n                Reader2Screen(viewModel)\n            }\n        }\n\n```&quot;,&quot;id&quot;:&quot;b117f698-3e37-47bb-a0b0-9133afea07f4&quot;,&quot;response&quot;:&quot;This code initializes the Reader2Activity when it's created. It sets up a dark transparent style for the system bars (status bar and navigation bar) and enables edge-to-edge display, which allows content to flow under the system bars. Then it calls the parent class's onCreate method and sets the content of the activity using Jetpack Compose. The content consists of a Reader2Screen component wrapped in a ReaderTheme, with the viewModel passed as a parameter to provide data and handle user interactions.\n\nThe main purpose is to set up the UI for an e-book reader with a modern edge-to-edge design. A potential improvement would be to extract the UI styling logic into a separate method to make the onCreate method more concise and focused on initialization.&quot;,&quot;referencedFilePaths&quot;:null,&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;codegpt.chat.completion&quot;,&quot;model&quot;:&quot;gpt-4o-mini&quot;,&quot;createdOn&quot;:[2025,3,24,13,10,27,115326000],&quot;updatedOn&quot;:[2025,3,24,13,19,3,904322000],&quot;discardTokenLimit&quot;:false}],&quot;anthropic.chat.completion&quot;:[{&quot;id&quot;:&quot;528b39ad-5f4a-4ddc-98eb-532538979511&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;Your task is to create concise, effective tests for the given code.\n\nGenerate unit tests for the provided code. Focus on:\n1. Testing main functionalities\n2. Edge cases\n3. Input validation\n\nProvide your test code in the same language as the original code. Use common testing frameworks and assertions appropriate for the language.\n\nHere's the code to write tests for:\n\n```kt\n    fun &lt;T&gt; observePref(prop: KProperty0&lt;T&gt;): Flow&lt;T&gt; = flow {\n        emit(prop.get())\n        emitAll(prefUpdateFlow.filter { it.name == prop.name }.map { prop.get() })\n    }\n```&quot;,&quot;id&quot;:&quot;2d557090-672f-43ec-abec-a8b95491431f&quot;,&quot;response&quot;:&quot;## Test Plan\n\n1. Test that `observePref` emits the current value immediately\n2. Test that `observePref` emits new values when the property changes\n3. Test that `observePref` only emits for the specific property being observed\n4. Test with different property types (String, Int, Boolean, custom object)\n5. Test edge case: rapid property changes\n\n```kotlin\npackage com.bookmate.common.android.preferences\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.test.core.app.ApplicationProvider\nimport app.cash.turbine.test\nimport io.mockk.every\nimport io.mockk.mockk\nimport io.mockk.verify\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.test.runTest\nimport org.junit.Assert.assertEquals\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.reflect.KProperty0\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalCoroutinesApi\nclass AbstractPreferencesTest {\n\n    private lateinit var testPreferences: TestPreferences\n    private lateinit var mockContext: Context\n    private lateinit var mockSharedPreferences: SharedPreferences\n    private lateinit var mockEditor: SharedPreferences.Editor\n\n    @Before\n    fun setup() {\n        mockContext = mockk(relaxed = true)\n        mockSharedPreferences = mockk(relaxed = true)\n        mockEditor = mockk(relaxed = true)\n        \n        every { mockContext.getSharedPreferences(any(), any()) } returns mockSharedPreferences\n        every { mockSharedPreferences.edit() } returns mockEditor\n        every { mockEditor.putString(any(), any()) } returns mockEditor\n        every { mockEditor.apply() } returns Unit\n        \n        testPreferences = TestPreferences()\n        testPreferences.init(mockContext)\n    }\n\n    @Test\n    fun `observePref emits current value immediately`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When\n        val flow = testPreferences.observePref(testPreferences::stringPref)\n        \n        // Then\n        val value = flow.first()\n        assertEquals(\&quot;initial\&quot;, value)\n    }\n\n    @Test\n    fun `observePref emits new values when property changes`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;initial\&quot;\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;initial\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            testPreferences.stringPref = \&quot;final\&quot;\n            assertEquals(\&quot;final\&quot;, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref only emits for specific property`() = runTest {\n        // Given\n        testPreferences.stringPref = \&quot;string\&quot;\n        testPreferences.intPref = 42\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::stringPref).test {\n            assertEquals(\&quot;string\&quot;, awaitItem())\n            \n            // Change different property\n            testPreferences.intPref = 100\n            \n            // Change observed property\n            testPreferences.stringPref = \&quot;updated\&quot;\n            assertEquals(\&quot;updated\&quot;, awaitItem())\n            \n            expectNoEvents()\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref works with different property types`() = runTest {\n        // Given\n        testPreferences.intPref = 42\n        testPreferences.boolPref = true\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test {\n            assertEquals(42, awaitItem())\n            testPreferences.intPref = 100\n            assertEquals(100, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n        \n        testPreferences.observePref(testPreferences::boolPref).test {\n            assertEquals(true, awaitItem())\n            testPreferences.boolPref = false\n            assertEquals(false, awaitItem())\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    @Test\n    fun `observePref handles rapid property changes`() = runTest {\n        // Given\n        testPreferences.intPref = 0\n        \n        // When/Then\n        testPreferences.observePref(testPreferences::intPref).test(timeout = 5.seconds) {\n            assertEquals(0, awaitItem())\n            \n            // Rapidly change property multiple times\n            for (i in 1..100) {\n                testPreferences.intPref = i\n            }\n            \n            // Should eventually receive the final value\n            assertEquals(100, awaitItem())\n            \n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n\n    private class TestPreferences : AbstractPreferences(\&quot;test_prefs\&quot;) {\n        var stringPref by SharedPreferenceDelegate.create&lt;String&gt;()\n        var intPref by SharedPreferenceDelegate.create&lt;Int&gt;()\n        var boolPref by SharedPreferenceDelegate.create&lt;Boolean&gt;()\n    }\n}\n```&quot;,&quot;referencedFilePaths&quot;:null,&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,24,13,21,55,136260000],&quot;updatedOn&quot;:[2025,3,24,13,26,42,431793000],&quot;discardTokenLimit&quot;:false},{&quot;id&quot;:&quot;5a57f2c7-c8d9-4081-be5f-ee10d4752219&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;напиши код, который блокирует выключение экрана на 15 минут&quot;,&quot;id&quot;:&quot;e33d0ec8-9c00-4bea-b839-c9ad6088d227&quot;,&quot;response&quot;:&quot;## Plan\n1. Add a method to prevent screen from turning off for 15 minutes\n2. Use WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON flag\n3. Use a timer to remove the flag after 15 minutes\n4. Add a call to this method where appropriate (likely in onCreate)\n\n## Implementation\n\n```kotlin\nprivate fun preventScreenTimeout() {\n    // Set flag to keep screen on\n    window.addFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n    \n    // Schedule removal of the flag after 15 minutes\n    val handler = android.os.Handler(android.os.Looper.getMainLooper())\n    handler.postDelayed({\n        window.clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n    }, 15 * 60 * 1000) // 15 minutes in milliseconds\n}\n\n// Call this method in onCreate after super.onCreate(savedInstanceState)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    val style = SystemBarStyle.dark(Color.TRANSPARENT)\n    enableEdgeToEdge(style, style)\n    super.onCreate(savedInstanceState)\n    \n    preventScreenTimeout() // Add this line\n    \n    setContent {\n        ReaderTheme {\n            Reader2Screen(viewModel)\n        }\n    }\n    // Rest of the method...\n}\n```&quot;,&quot;referencedFilePaths&quot;:[&quot;/Users/pavelperc/arcadia/bookmate/android/feature/reader2/src/main/java/com/bookmate/feature/reader2/ui2/Reader2Activity.kt&quot;],&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null},{&quot;prompt&quot;:&quot;Вынеси это в отдельный файл в ActivityScoped и добавь сброс таймера при любом клике на экран. Также перепиши таймер на корутины.&quot;,&quot;id&quot;:&quot;ddd999b7-e3bd-4ca4-88ed-59131331321b&quot;,&quot;response&quot;:&quot;## Plan\n1. Create a new class `ScreenTimeoutManager` with ActivityScoped annotation\n2. Move the screen timeout prevention logic there\n3. Add a method to reset the timer\n4. Replace Handler with coroutines\n5. Add a way to detect screen touches and reset the timer\n\nHere's the implementation:\n\n```kotlin\npackage com.bookmate.feature.reader2.ui2\n\nimport android.view.MotionEvent\nimport android.view.Window\nimport androidx.lifecycle.DefaultLifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport dagger.hilt.android.scopes.ActivityScoped\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport javax.inject.Inject\n\n@ActivityScoped\nclass ScreenTimeoutManager @Inject constructor() : DefaultLifecycleObserver {\n    \n    private var timeoutJob: Job? = null\n    private val coroutineScope = CoroutineScope(Dispatchers.Main)\n    private lateinit var window: Window\n    \n    fun initialize(window: Window) {\n        this.window = window\n    }\n    \n    fun preventScreenTimeout() {\n        window.addFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n        scheduleTimeout()\n    }\n    \n    fun resetTimeout() {\n        timeoutJob?.cancel()\n        scheduleTimeout()\n    }\n    \n    private fun scheduleTimeout() {\n        timeoutJob = coroutineScope.launch {\n            delay(15 * 60 * 1000) // 15 minutes in milliseconds\n            window.clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n        }\n    }\n    \n    fun onTouchEvent(event: MotionEvent): Boolean {\n        if (event.action == MotionEvent.ACTION_DOWN) {\n            resetTimeout()\n        }\n        return false\n    }\n    \n    override fun onStop(owner: LifecycleOwner) {\n        timeoutJob?.cancel()\n        window.clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n    }\n}\n```\n\nNow modify the Reader2Activity to use this manager:\n\n```kotlin\n@AndroidEntryPoint\nclass Reader2Activity : BaseActivity() {\n\n    private val viewModel: Reader2ViewModel by viewModels()\n    \n    @Inject\n    lateinit var screenTimeoutManager: ScreenTimeoutManager\n\n    // ... existing code ...\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        val style = SystemBarStyle.dark(Color.TRANSPARENT)\n        enableEdgeToEdge(style, style)\n        super.onCreate(savedInstanceState)\n        \n        screenTimeoutManager.initialize(window)\n        screenTimeoutManager.preventScreenTimeout()\n        lifecycle.addObserver(screenTimeoutManager)\n        \n        setContent {\n            ReaderTheme {\n                Reader2Screen(viewModel)\n            }\n        }\n\n        // ... existing code ...\n    }\n    \n    override fun dispatchTouchEvent(ev: MotionEvent): Boolean {\n        screenTimeoutManager.onTouchEvent(ev)\n        return super.dispatchTouchEvent(ev)\n    }\n    \n    // Remove the preventScreenTimeout method from this class\n    \n    // ... rest of the existing code ...\n}\n```&quot;,&quot;referencedFilePaths&quot;:[&quot;/Users/pavelperc/arcadia/bookmate/android/feature/reader2/src/main/java/com/bookmate/feature/reader2/ui2/Reader2Activity.kt&quot;],&quot;imageFilePath&quot;:null,&quot;webSearchIncluded&quot;:false,&quot;documentationDetails&quot;:null,&quot;personaName&quot;:null}],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,24,13,38,34,676691000],&quot;updatedOn&quot;:[2025,3,24,13,40,28,665520000],&quot;discardTokenLimit&quot;:false},{&quot;id&quot;:&quot;06dd7f59-dcd7-4f25-acbc-34eabd637fa5&quot;,&quot;messages&quot;:[],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,25,15,42,51,562413000],&quot;updatedOn&quot;:[2025,3,25,15,42,51,562415000],&quot;discardTokenLimit&quot;:false}]}}" />
    <option name="currentConversation" value="{&quot;id&quot;:&quot;06dd7f59-dcd7-4f25-acbc-34eabd637fa5&quot;,&quot;messages&quot;:[],&quot;clientCode&quot;:&quot;anthropic.chat.completion&quot;,&quot;model&quot;:&quot;claude-3-7-sonnet-20250219&quot;,&quot;createdOn&quot;:[2025,3,25,15,42,51,562413000],&quot;updatedOn&quot;:[2025,3,25,15,42,51,562415000],&quot;discardTokenLimit&quot;:false}" />
  </component>
</application>